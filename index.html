<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gridspace Whiteboard</title>
    
    <!-- React and Babel for JSX in browser -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Firebase -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc, deleteDoc, collection, query, where, getDocs, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";
        window.firebase = {
            initializeApp,
            getAuth,
            signInAnonymously,
            onAuthStateChanged,
            getFirestore,
            doc, setDoc, getDoc, onSnapshot, updateDoc, deleteDoc, collection, query, where, getDocs, serverTimestamp
        };
    </script>
    
    <style>
        /* --- Global Styles & Fonts --- */
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto+Mono&display=swap');

        /* --- Theme Variables --- */
        :root {
            --font-main: 'Orbitron', sans-serif;
            
            /* Default Theme: Nebula */
            --bg-primary: radial-gradient(circle, #4c0070 0%, #110022 100%);
            --bg-secondary: rgba(26, 10, 51, 0.8);
            --bg-tertiary: rgba(0, 0, 0, 0.3);
            --text-primary: #f0f0f0;
            --text-secondary: #c0c0c0;
            --border-primary: rgba(255, 0, 255, 0.5);
            --accent-primary: #ff00ff;
            --accent-secondary: #00ffff;
            --accent-glow: rgba(255, 0, 255, 0.6);
            --grid-dot-color: rgba(255, 255, 255, 0.1);
            --btn-text-color: #ffffff;
        }
        
        body {
            margin: 0;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: var(--font-main);
            transition: background 0.5s, color 0.5s;
            overflow: hidden;
        }

        /* --- Layout & General Components --- */
        .app-container { min-height: 100vh; }
        .screen { display: flex; flex-direction: column; height: 100vh; width: 100vw; }
        .flex { display: flex; }
        .flex-1 { flex: 1 1 0%; }
        .items-center { align-items: center; }
        .justify-center { justify-content: center; }
        .justify-between { justify-content: space-between; }
        .p-4 { padding: 1rem; }
        .gap-2 { gap: 0.5rem; }
        .gap-4 { gap: 1rem; }
        .rounded-lg { border-radius: 0.5rem; }
        .rounded-full { border-radius: 9999px; }
        .shadow-glow { box-shadow: 0 0 20px var(--accent-glow); }
        .cursor-grabbing { cursor: grabbing; }
        .cursor-crosshair { cursor: crosshair; }
        
        /* --- HomeScreen --- */
        .home-screen-container { 
            height: 100vh; 
            padding: 1rem; 
            display: flex;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
        }
        .home-card {
            width: 100%;
            max-width: 32rem;
            margin: auto;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            padding: 2rem;
            opacity: 0;
            transform: translateY(20px);
            animation: slideUpFadeIn 0.7s ease-out forwards;
            backdrop-filter: blur(10px);
        }
        @keyframes slideUpFadeIn { to { opacity: 1; transform: translateY(0); } }
        .home-card h1 { font-size: 2.25rem; font-weight: bold; text-align: center; color: var(--accent-primary); margin-bottom: 0.5rem; letter-spacing: 0.05em; }
        .home-card p { text-align: center; color: var(--text-secondary); margin-bottom: 1rem; }
        .home-card .uid-span { font-family: 'Roboto Mono', monospace; background-color: var(--bg-tertiary); padding: 0.25rem; border-radius: 0.25rem; color: var(--accent-secondary); }
        .input-group { margin-bottom: 1.5rem; }
        .input-label { display: block; font-size: 0.875rem; font-weight: 500; color: var(--text-secondary); margin-bottom: 0.5rem; }
        .text-input {
            width: 100%; padding: 0.75rem 1rem; background-color: var(--bg-primary); border: 1px solid var(--border-primary);
            border-radius: 0.375rem; transition: border-color 0.2s, box-shadow 0.2s; color: var(--text-primary); font-family: inherit;
            box-sizing: border-box; /* FIX: Prevents overflow */
        }
        .text-input:focus { outline: none; border-color: var(--accent-primary); box-shadow: 0 0 0 2px var(--accent-glow); }
        .session-box { padding: 1.5rem; border: 1px solid var(--border-primary); border-radius: 0.375rem; margin-bottom: 1.5rem; background-color: var(--bg-tertiary); }
        .session-box h2 { font-size: 1.5rem; font-weight: 600; color: var(--text-primary); margin-bottom: 1rem; }
        .btn {
            width: 100%; display: inline-flex; align-items: center; justify-content: center; font-weight: bold; padding: 0.75rem 1rem;
            border-radius: 0.375rem; transition: all 0.3s; border: none; cursor: pointer; font-family: inherit;
        }
        .btn-primary { background-color: var(--accent-primary); color: var(--btn-text-color, var(--bg-primary)); }
        .btn-primary:hover { box-shadow: 0 0 20px var(--accent-glow); }
        .btn-secondary { background-color: var(--accent-secondary); color: var(--btn-text-color, var(--bg-primary)); }
        .btn-secondary:hover { box-shadow: 0 0 20px var(--accent-glow); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .error-message { color: #f43f5e; text-align: center; margin-top: 1.5rem; }

        /* --- WhiteboardScreen --- */
        .header {
            background-color: var(--bg-secondary); border-bottom: 1px solid var(--border-primary); box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 0.75rem; z-index: 20;
        }
        .header h1 { font-size: 1.5rem; font-weight: bold; color: var(--accent-primary); letter-spacing: 0.05em; }
        .header .coords-group { margin-left: 1.5rem; }
        .header .coords-label { font-weight: 600; color: var(--text-secondary); }
        .header .coords-code { font-family: 'Roboto Mono', monospace; background-color: var(--bg-tertiary); color: var(--accent-primary); padding: 0.25rem 0.75rem; border-radius: 0.375rem; }
        .header .user-info { font-size: 0.875rem; color: var(--text-secondary); }
        .header .btn-icon { background: none; border: none; padding: 0.5rem; border-radius: 9999px; cursor: pointer; transition: background-color 0.2s, transform 0.2s; }
        .header .btn-icon:hover { background-color: var(--bg-tertiary); transform: scale(1.1); }
        .btn-leave { background-color: rgba(239, 68, 68, 0.8); color: white; }
        .btn-leave:hover { background-color: #ef4444; }

        .main-canvas {
            position: absolute; top: 1rem; left: 1rem; width: calc(100% - 2rem); height: calc(100% - 2rem);
            background-color: var(--bg-secondary); border-radius: 0.375rem; border: 1px solid var(--border-primary);
            box-shadow: 0 0 20px var(--accent-glow); background-image: radial-gradient(var(--grid-dot-color) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .zoom-indicator {
            position: absolute; bottom: 1.25rem; right: 1.25rem; background-color: var(--bg-tertiary); color: var(--text-secondary);
            font-size: 0.75rem; font-family: 'Roboto Mono', monospace; padding: 0.25rem 0.5rem; border-radius: 0.375rem; z-index: 20;
        }
        .cursor-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; }
        .user-cursor { position: absolute; display: flex; align-items: center; }
        .user-cursor-label { padding: 2px 6px; border-radius: 4px; font-size: 12px; font-family: sans-serif; white-space: nowrap; margin-left: 4px; }

        /* --- Sidebar --- */
        .sidebar {
            width: 20rem; background-color: var(--bg-secondary); border-left: 1px solid var(--border-primary); padding: 1rem;
            overflow-y: auto; z-index: 20; transform: translateX(100%); animation: slideInFromRight 0.5s ease-out forwards;
        }
        @keyframes slideInFromRight { to { transform: translateX(0); } }
        .sidebar h3 { font-weight: bold; font-size: 1.125rem; margin-bottom: 0.5rem; color: var(--accent-primary); }
        .sidebar .invite-text { font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 0.75rem; font-style: italic; }
        .pending-request { background-color: var(--bg-tertiary); padding: 0.75rem; border-radius: 0.375rem; }
        .participant-card { 
            background-color: var(--bg-primary); border: 1px solid var(--border-primary); padding: 0.75rem; 
            border-radius: 0.375rem; transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
        }
        .participant-card:hover { transform: translateY(-2px); box-shadow: 0 0 15px var(--accent-glow); }
        .btn-permission { font-size: 0.75rem; font-weight: 600; padding: 0.25rem 0.75rem; border-radius: 9999px; border: none; cursor: pointer; }
        .btn-allow-draw { background-color: rgba(52, 211, 153, 0.2); color: #6ee7b7; }
        .btn-watch-only { background-color: rgba(250, 204, 21, 0.2); color: #facc15; }

        /* --- Toolbar --- */
        .toolbar {
            position: absolute; bottom: 1rem; left: 50%; transform: translateX(-50%) translateY(100%);
            background-color: var(--bg-secondary); border: 1px solid var(--border-primary); box-shadow: 0 0 25px var(--accent-glow);
            border-radius: 0.5rem; padding: 0.5rem; display: flex; align-items: center; gap: 0.5rem; z-index: 30;
            animation: slideUpFromBottom 0.5s 0.2s ease-out forwards;
        }
        @keyframes slideUpFromBottom { to { transform: translateX(-50%) translateY(0); } }
        .tool-group { display: flex; align-items: center; background-color: var(--bg-primary); padding: 0.25rem; border-radius: 0.375rem; }
        .toolbar-btn { background: none; border: none; padding: 0.5rem; border-radius: 0.375rem; cursor: pointer; transition: all 0.2s; color: var(--text-secondary); }
        .toolbar-btn:hover { background-color: var(--bg-tertiary); color: var(--text-primary); }
        .toolbar-btn.active { background-color: var(--accent-primary); color: var(--btn-text-color, var(--bg-primary)); transform: scale(1.1); }
        .toolbar-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .divider { width: 1px; height: 2rem; background-color: var(--border-primary); }
        .color-palette { display: flex; align-items: center; gap: 0.5rem; }
        .color-btn { width: 2rem; height: 2rem; border-radius: 9999px; border: none; cursor: pointer; transition: transform 0.2s; }
        .color-btn:hover { transform: scale(1.1); }
        .color-btn.active { box-shadow: 0 0 0 2px var(--bg-secondary), 0 0 0 4px var(--accent-primary); }
        .color-picker-wrapper { position: relative; }
        .color-picker-btn { position: absolute; top: -0.25rem; right: -0.25rem; background-color: var(--bg-tertiary); padding: 0.125rem; border-radius: 9999px; opacity: 0; transition: opacity 0.2s; }
        .color-picker-wrapper:hover .color-picker-btn { opacity: 1; }
        .color-input { position: absolute; width: 0; height: 0; opacity: 0; }
        .btn-purge { background-color: rgba(244, 63, 94, 0.2); color: #f43f5e; }
        .btn-purge:hover { background-color: rgba(244, 63, 94, 0.4); }

        /* --- Overlays --- */
        .overlay {
            position: absolute; inset: 0; background-color: var(--bg-overlay); display: flex; flex-direction: column;
            align-items: center; justify-content: center; border-radius: 0.375rem; color: var(--text-primary);
            backdrop-filter: blur(4px); z-index: 20; opacity: 0; animation: fadeIn 0.3s ease-out forwards;
        }
        @keyframes fadeIn { to { opacity: 1; } }
        .overlay h2 { font-size: 1.875rem; font-weight: bold; color: var(--accent-primary); }
        .overlay p { margin-top: 0.5rem; font-size: 1.125rem; color: var(--text-secondary); }
        .watch-only-badge {
            position: absolute; top: 1rem; right: 1rem; background-color: rgba(250, 204, 21, 0.2);
            color: #facc15; border: 1px solid rgba(250, 204, 21, 0.5); font-weight: bold; padding: 0.5rem 1rem;
            border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0,0,0,0.1); display: flex; align-items: center;
            gap: 0.5rem; backdrop-filter: blur(4px); z-index: 20; opacity: 0; animation: fadeIn 0.3s ease-out forwards;
        }

        /* --- Theme Selector --- */
        .theme-selector { display: flex; align-items: center; gap: 0.5rem; position: relative; }
        .theme-btn {
            width: 1.5rem; height: 1.5rem; border-radius: 9999px; border: 2px solid var(--border-primary);
            cursor: pointer; transition: all 0.2s;
        }
        .theme-btn.active { border-color: var(--accent-primary); transform: scale(1.2); }
        .theme-dropdown {
            position: absolute;
            top: calc(100% + 10px);
            right: 0;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 0.5rem;
            padding: 0.5rem;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            z-index: 100;
            display: flex;
            gap: 0.5rem;
            opacity: 0;
            transform: translateY(10px);
            animation: fadeIn 0.2s ease-out forwards;
            pointer-events: none;
        }
        .theme-selector:hover .theme-dropdown {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        const { initializeApp, getAuth, signInAnonymously, onAuthStateChanged, getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc, deleteDoc, collection, query, where, getDocs, serverTimestamp } = window.firebase;

        // --- Firebase Configuration ---
        const firebaseConfig = {
          apiKey: "AIzaSyBIrYTsM-yd_jwQ5d0tCNO1GF1Koztemdc",
          authDomain: "gridspace-whiteboard.firebaseapp.com",
          projectId: "gridspace-whiteboard",
          storageBucket: "gridspace-whiteboard.firebasestorage.app",
          messagingSenderId: "142967188261",
          appId: "1:142967188261:web:1ba1f02e649fd4c94f08cc"
        };
        const appId = 'gridspace-whiteboard-public';

        // --- Firebase Initialization ---
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- Helper Functions & Constants ---
        const generateShortCode = (length = 5) => {
            const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < length; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        };

        const FONT_SIZE = 24;
        const LINE_HEIGHT = 1.2;
        const RESIZE_HANDLE_WIDTH = 8;
        
        // --- THEME DEFINITIONS ---
        const themes = {
            "Nebula": {
                '--bg-primary': 'radial-gradient(circle, #4c0070 0%, #110022 100%)', '--bg-secondary': 'rgba(26, 10, 51, 0.8)', '--bg-tertiary': 'rgba(0, 0, 0, 0.3)',
                '--text-primary': '#f0f0f0', '--text-secondary': '#c0c0c0',
                '--border-primary': 'rgba(255, 0, 255, 0.5)', '--accent-primary': '#ff00ff', '--accent-secondary': '#00ffff', '--accent-glow': 'rgba(255, 0, 255, 0.6)',
                '--grid-dot-color': 'rgba(255, 255, 255, 0.1)', '--btn-text-color': '#ffffff',
            },
            "Blueprint": {
                '--bg-primary': '#002b4d', '--bg-secondary': '#003f70', '--bg-tertiary': 'rgba(255, 255, 255, 0.1)',
                '--text-primary': '#ffffff', '--text-secondary': '#aaccff',
                '--border-primary': '#005f9e', '--accent-primary': '#ffffff', '--accent-secondary': '#ffd700', '--accent-glow': 'rgba(255, 255, 255, 0.5)',
                '--grid-dot-color': 'rgba(173, 216, 230, 0.3)', '--btn-text-color': '#002b4d',
            },
            "Arcade": {
                '--bg-primary': '#000000', '--bg-secondary': '#1a1a1a', '--bg-tertiary': '#333333',
                '--text-primary': '#00ff00', '--text-secondary': '#00cc00',
                '--border-primary': '#00ff00', '--accent-primary': '#00ff00', '--accent-secondary': '#ff00ff', '--accent-glow': 'rgba(0, 255, 0, 0.6)',
                '--grid-dot-color': 'rgba(0, 255, 0, 0.2)', '--btn-text-color': '#000000',
            },
             "Dark": {
                '--bg-primary': '#121212', '--bg-secondary': '#1e1e1e', '--bg-tertiary': '#2d2d2d',
                '--text-primary': '#e4e6eb', '--text-secondary': '#b0b3b8',
                '--border-primary': '#3a3b3c', '--accent-primary': '#00aaff', '--accent-secondary': '#00ffaa', '--accent-glow': 'rgba(0, 170, 255, 0.5)',
                '--grid-dot-color': 'rgba(255, 255, 255, 0.1)', '--btn-text-color': '#121212',
            },
            "Blue": {
                '--bg-primary': '#0a192f', '--bg-secondary': '#112240', '--bg-tertiary': '#0d2a52',
                '--text-primary': '#ccd6f6', '--text-secondary': '#8892b0',
                '--border-primary': '#233554', '--accent-primary': '#64ffda', '--accent-secondary': '#ff64a2', '--accent-glow': 'rgba(100, 255, 218, 0.4)',
                '--grid-dot-color': 'rgba(136, 146, 176, 0.2)', '--btn-text-color': '#0a192f',
            },
            "Cyberpunk": {
                '--bg-primary': '#0d0221', '--bg-secondary': '#261447', '--bg-tertiary': '#0d0221',
                '--text-primary': '#f0f2f5', '--text-secondary': '#a89ed0',
                '--border-primary': '#3a2d5c', '--accent-primary': '#f43f5e', '--accent-secondary': '#00f6ff', '--accent-glow': 'rgba(244, 63, 94, 0.5)',
                '--grid-dot-color': 'rgba(168, 158, 208, 0.2)', '--btn-text-color': '#ffffff',
            }
        };

        // --- Data & Drawing Logic ---
        const getElementBounds = (element) => {
            if (!element) return null;
            const { type, x, y, path, width, height, x2, y2, radius } = element;
            const padding = (element.lineWidth || 0) / 2 + 5;

            switch (type) {
                case 'path': {
                    const xs = path.map(p => p.x);
                    const ys = path.map(p => p.y);
                    const minX = Math.min(...xs);
                    const minY = Math.min(...ys);
                    const maxX = Math.max(...xs);
                    const maxY = Math.max(...ys);
                    return { x: minX - padding, y: minY - padding, width: (maxX - minX) + padding * 2, height: (maxY - minY) + padding * 2 };
                }
                case 'rectangle':
                case 'text': {
                     const bounds = { x: Math.min(x, x + width), y: Math.min(y, y + height), width: Math.abs(width), height: Math.abs(height) };
                     return { x: bounds.x - 5, y: bounds.y - 5, width: bounds.width + 10, height: bounds.height + 10 };
                }
                case 'circle': {
                    return { x: x - radius - padding, y: y - radius - padding, width: (radius + padding) * 2, height: (radius + padding) * 2 };
                }
                case 'line': {
                    const bounds = { x: Math.min(x, x2), y: Math.min(y, y2), width: Math.abs(x - x2), height: Math.abs(y - y2) };
                    return { x: bounds.x - padding, y: bounds.y - padding, width: bounds.width + padding * 2, height: bounds.height + padding * 2 };
                }
                default: return null;
            }
        };

        const isPointInsideBounds = (point, bounds) => {
            if (!bounds) return false;
            return point.x >= bounds.x && point.x <= bounds.x + bounds.width && point.y >= bounds.y && point.y <= bounds.y + bounds.height;
        };

        const doBoundsIntersect = (b1, b2) => {
            return !(b2.x > b1.x + b1.width || b2.x + b2.width < b1.x || b2.y > b1.y + b1.height || b2.y + b2.height < b1.y);
        };

        // --- Icon Component ---
        const Icon = ({ name, size = 20 }) => {
            const icons = {
                Edit: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>,
                ArrowLeft: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M19 12H5"/><path d="M12 19l-7-7 7-7"/></svg>,
                LogOut: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/><polyline points="16 17 21 12 16 7"/><line x1="21" y1="12" x2="9" y2="12"/></svg>,
                Check: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="20 6 9 17 4 12"/></svg>,
                X: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>,
                Eye: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>,
                MousePointer: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/><path d="M13 13l6 6"/></svg>,
                Minus: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="5" y1="12" x2="19" y2="12"/></svg>,
                Square: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/></svg>,
                Circle: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/></svg>,
                Type: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg>,
                SquareSlash: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 21H3V3h18v18z"/><path d="M21 3L3 21"/></svg>,
                Undo: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><path d="M3 10v6a6 6 0 0 0 6 6h10"/><path d="m7 10-4 4 4 4"/></svg>,
                Redo: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><path d="M21 10v6a6 6 0 0 1-6 6H5"/><path d="m17 10 4 4-4 4"/></svg>,
                Pipette: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m2 22 5.5-5.5"/><path d="m13.02 5.02 2.83-2.83c.2-.2.45-.29.71-.29a1 1 0 0 1 .71.29l2.83 2.83c.2.2.29.45.29.71 0 .26-.09.51-.29.71L19 9"/><path d="m14.5 6.5 5 5"/><path d="M12 10.52c-1.71 1.71-2.43 4.29-2.52 6.48-.04.97.23 1.94.73 2.73.5.79 1.25 1.4 2.12 1.76.87.36 1.83.4 2.76.13 2.19-.63 4.77-1.35 6.48-2.52"/></svg>,
                Plus: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>,
                Trash2: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 6h18"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>,
                Palette: <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="13.5" cy="6.5" r=".5"/><circle cx="17.5" cy="10.5" r=".5"/><circle cx="8.5" cy="7.5" r=".5"/><circle cx="6.5" cy="12.5" r=".5"/><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.667 0-.424-.163-.82-.429-1.125-.295-.33-1.002-.92-1.002-1.002V12c0-1.105.895-2 2-2h.001c1.105 0 2 .895 2 2v1.167c0 .082-.707.672-1.002 1.002-.266.305-.429.701-.429 1.125 0 .92.722 1.667 1.648 1.667C17.5 22 22 17.5 22 12S17.5 2 12 2z"/></svg>,
            };
            return icons[name] || null;
        };

        // --- Main App Component ---
        function App() {
            const [user, setUser] = useState(null);
            const [loading, setLoading] = useState(true);
            const [session, setSession] = useState(null);
            const [theme, setTheme] = useState('nebula');

            useEffect(() => {
                const selectedTheme = themes[theme];
                if (!selectedTheme) return;

                document.documentElement.setAttribute('data-theme', theme.toLowerCase());
                document.body.style.fontFamily = "'Orbitron', sans-serif";
                Object.entries(selectedTheme).forEach(([key, value]) => {
                    document.documentElement.style.setProperty(key, value);
                });
            }, [theme]);

            useEffect(() => {
                const initAuth = async () => {
                    try {
                        await signInAnonymously(auth);
                    } catch (error) {
                        console.error("Anonymous sign-in failed:", error);
                    }
                };

                const unsubscribe = onAuthStateChanged(auth, (currentUser) => {
                    setUser(currentUser);
                    setLoading(false);
                });
                
                initAuth();
                
                return () => unsubscribe();
            }, []);

            const handleSetSession = (sessionData) => setSession(sessionData);

            const handleLeaveSession = async () => {
                if (session && user) {
                    const sessionRef = doc(db, `/artifacts/${appId}/public/data/sessions`, session.id);
                    await updateDoc(sessionRef, { [`participants.${user.uid}`]: null });
                    await deleteDoc(doc(db, `/artifacts/${appId}/public/data/sessions/${session.id}/cursors`, user.uid));
                }
                setSession(null);
            };

            if (loading) return <div className="flex items-center justify-center app-container">Loading Systems...</div>;
            if (!user) return <div className="flex items-center justify-center app-container">Authenticating User...</div>;

            return (
                <div className="app-container">
                    {session ? (
                        <WhiteboardScreen session={session} user={user} onLeave={handleLeaveSession} theme={theme} setTheme={setTheme} />
                    ) : (
                        <HomeScreen user={user} onJoinSession={handleSetSession} />
                    )}
                </div>
            );
        }
        
        // --- HomeScreen Component ---
        function HomeScreen({ user, onJoinSession }) {
            const [isMounted, setIsMounted] = useState(false);
            useEffect(() => setIsMounted(true), []);

            const [joinCode, setJoinCode] = useState('');
            const [error, setError] = useState('');
            const [userName, setUserName] = useState('');
            const handleCreateSession = async () => {
                if (!userName.trim()) { setError('Please enter your call-sign.'); return; }
                setError('');
                const shortCode = generateShortCode();
                const sessionRef = doc(db, `/artifacts/${appId}/public/data/sessions`, shortCode);
                const newSession = {
                    hostId: user.uid, shortCode, createdAt: serverTimestamp(),
                    participants: { [user.uid]: { name: userName, permission: 'draw' } },
                    pendingRequests: {}, drawingData: JSON.stringify([]),
                    theme: 'nebula' // Default theme
                };
                await setDoc(sessionRef, newSession);
                onJoinSession({ ...newSession, id: shortCode });
            };
            const handleJoinSession = async () => {
                if (!userName.trim()) { setError('Please enter your call-sign.'); return; }
                if (!joinCode.trim()) { setError('Please enter a session code.'); return; }
                setError('');
                const q = query(collection(db, `/artifacts/${appId}/public/data/sessions`), where("shortCode", "==", joinCode.toLowerCase()));
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    setError('Session not found. Invalid coordinates.');
                } else {
                    const sessionDoc = querySnapshot.docs[0];
                    await updateDoc(sessionDoc.ref, { [`pendingRequests.${user.uid}`]: { name: userName } });
                    onJoinSession({ ...sessionDoc.data(), id: sessionDoc.id });
                }
            };
            return (
                <div className="home-screen-container">
                    <div className="home-card shadow-glow">
                        <h1>GRIDSPACE WHITEBOARD</h1>
                        <p>Real-time Visual Collaboration. Your UID: <span className="uid-span">{user?.uid || '...'}</span></p>
                        
                        <div className="input-group">
                            <label htmlFor="name" className="input-label">Call-Sign</label>
                            <input id="name" type="text" value={userName} onChange={(e) => setUserName(e.target.value)} placeholder="Enter your name"
                                className="text-input" />
                        </div>
                        <div style={{display: 'flex', flexDirection: 'column', gap: '1.5rem'}}>
                            <div className="session-box">
                                <h2>Initiate New Session</h2>
                                <button onClick={handleCreateSession} disabled={!userName.trim()} className="btn btn-primary">
                                    <Icon name="Edit" size={16} /> <span style={{marginLeft: '0.5rem'}}>Create & Engage</span>
                                </button>
                            </div>
                            <div className="session-box">
                                <h2>Join Existing Session</h2>
                                <input type="text" value={joinCode} onChange={(e) => setJoinCode(e.target.value)} placeholder="Enter session coordinates"
                                    className="text-input" style={{marginBottom: '1rem'}} />
                                <button onClick={handleJoinSession} disabled={!userName.trim() || !joinCode.trim()} className="btn btn-secondary">
                                    <Icon name="ArrowLeft" size={16} /> <span style={{marginLeft: '0.5rem'}}>Request Sync</span>
                                </button>
                            </div>
                        </div>
                        {error && <p className="error-message">{error}</p>}
                    </div>
                </div>
            );
        }

        // --- WhiteboardScreen Component ---
        function WhiteboardScreen({ session: initialSession, user, onLeave, theme, setTheme }) {
            const canvasRef = useRef(null);
            const textInputRef = useRef(null);

            const [sessionData, setSessionData] = useState(initialSession);
            const [elements, setElements] = useState([]);
            const [history, setHistory] = useState([[]]);
            const [historyIndex, setHistoryIndex] = useState(0);
            
            const [action, setAction] = useState('none');
            const [tool, setTool] = useState('pen');
            const [shape, setShape] = useState('rectangle');
            const [color, setColor] = useState('#ff00ff');
            const [lineWidth, setLineWidth] = useState(5);
            const [quickColors, setQuickColors] = useState(['#ff00ff', '#00ffff', '#00ff00', '#ffff00']);
            
            const [selectedElements, setSelectedElements] = useState([]);
            const [startPoint, setStartPoint] = useState(null);
            const [textInput, setTextInput] = useState({ visible: false, x: 0, y: 0, width: 0, height: 0, value: '' });
            const [isSpacePressed, setIsSpacePressed] = useState(false);
            const [viewTransform, setViewTransform] = useState({ scale: 1, offsetX: 0, offsetY: 0 });
            const [selectionRect, setSelectionRect] = useState(null);
            const [cursors, setCursors] = useState({});
            const lastCursorUpdate = useRef(0);

            const userPermission = sessionData.participants[user.uid]?.permission || (sessionData.pendingRequests[user.uid] ? 'pending' : 'none');
            const isHost = sessionData.hostId === user.uid;

            const updateFirestoreWithHistory = (newHistory, newIndex) => {
                const sessionRef = doc(db, `/artifacts/${appId}/public/data/sessions`, initialSession.id);
                const dataToSave = { drawingData: JSON.stringify(newHistory[newIndex]) };
                updateDoc(sessionRef, dataToSave);
            };

            const updateHistory = (newElements) => {
                const newHistory = [...history.slice(0, historyIndex + 1), newElements];
                setHistory(newHistory);
                setHistoryIndex(newHistory.length - 1);
                updateFirestoreWithHistory(newHistory, newHistory.length - 1);
            };

            const handleUndo = () => { if (historyIndex > 0) { const newIndex = historyIndex - 1; setHistoryIndex(newIndex); setElements(history[newIndex]); updateFirestoreWithHistory(history, newIndex); } };
            const handleRedo = () => { if (historyIndex < history.length - 1) { const newIndex = historyIndex + 1; setHistoryIndex(newIndex); setElements(history[newIndex]); updateFirestoreWithHistory(history, newIndex); } };

            const drawElement = useCallback((ctx, element) => {
                if (!element) return;
                ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.strokeStyle = element.color; ctx.lineWidth = element.lineWidth; ctx.shadowBlur = element.lineWidth / 2; ctx.shadowColor = element.color; ctx.fillStyle = element.color;
                switch (element.type) {
                    case 'path':
                        ctx.beginPath(); ctx.moveTo(element.path[0].x, element.path[0].y); element.path.forEach(p => ctx.lineTo(p.x, p.y)); ctx.stroke(); break;
                    case 'rectangle': ctx.strokeRect(element.x, element.y, element.width, element.height); break;
                    case 'circle': ctx.beginPath(); ctx.arc(element.x, element.y, element.radius, 0, 2 * Math.PI); ctx.stroke(); break;
                    case 'line': ctx.beginPath(); ctx.moveTo(element.x, element.y); ctx.lineTo(element.x2, element.y2); ctx.stroke(); break;
                    case 'text':
                        const fontName = getComputedStyle(document.documentElement).fontFamily;
                        ctx.font = `${FONT_SIZE}px ${fontName}`; ctx.textBaseline = 'top';
                        if (element.text) {
                            const words = element.text.split(' '); let line = ''; let currentY = element.y;
                            for (let n = 0; n < words.length; n++) {
                                const testLine = line + words[n] + ' '; const metrics = ctx.measureText(testLine); const testWidth = metrics.width;
                                if (testWidth > Math.abs(element.width) && n > 0) { ctx.fillText(line, element.x, currentY); line = words[n] + ' '; currentY += FONT_SIZE * LINE_HEIGHT; } else { line = testLine; }
                            }
                            ctx.fillText(line, element.x, currentY);
                        }
                        break;
                }
                ctx.shadowBlur = 0;
            }, []);

            const redrawCanvas = useCallback(() => {
                const canvas = canvasRef.current; if (!canvas) return; const ctx = canvas.getContext('2d'); ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save(); ctx.translate(viewTransform.offsetX, viewTransform.offsetY); ctx.scale(viewTransform.scale, viewTransform.scale);
                elements.forEach(element => drawElement(ctx, element));
                ctx.restore();

                if (selectedElements.length > 0) {
                    ctx.save(); ctx.translate(viewTransform.offsetX, viewTransform.offsetY); ctx.scale(viewTransform.scale, viewTransform.scale);
                    ctx.strokeStyle = 'var(--accent-primary)'; ctx.lineWidth = 1 / viewTransform.scale; ctx.setLineDash([6 / viewTransform.scale, 4 / viewTransform.scale]);
                    selectedElements.forEach(selectedId => {
                        const element = elements.find(el => el.id === selectedId); const bounds = getElementBounds(element);
                        if (bounds) { 
                            ctx.strokeRect(bounds.x - 5, bounds.y - 5, bounds.width + 10, bounds.height + 10);
                            if(selectedElements.length === 1){ // Draw resize handles for single selection
                                ctx.fillStyle = 'var(--accent-primary)';
                                const handleSize = RESIZE_HANDLE_WIDTH / viewTransform.scale;
                                ctx.fillRect(bounds.x - 5 - handleSize/2, bounds.y - 5 - handleSize/2, handleSize, handleSize);
                                ctx.fillRect(bounds.x + bounds.width + 5 - handleSize/2, bounds.y - 5 - handleSize/2, handleSize, handleSize);
                                ctx.fillRect(bounds.x - 5 - handleSize/2, bounds.y + bounds.height + 5 - handleSize/2, handleSize, handleSize);
                                ctx.fillRect(bounds.x + bounds.width + 5 - handleSize/2, bounds.y + bounds.height + 5 - handleSize/2, handleSize, handleSize);
                            }
                        }
                    });
                    ctx.restore();
                }
                
                if (selectionRect) {
                    ctx.save(); ctx.strokeStyle = 'var(--accent-primary)'; ctx.fillStyle = 'rgba(0, 170, 255, 0.1)'; ctx.lineWidth = 1; ctx.setLineDash([6, 4]);
                    ctx.strokeRect(selectionRect.x, selectionRect.y, selectionRect.width, selectionRect.height); ctx.fillRect(selectionRect.x, selectionRect.y, selectionRect.width, selectionRect.height);
                    ctx.restore();
                }
            }, [elements, drawElement, selectedElements, viewTransform, selectionRect]);

            useEffect(() => {
                const sessionRef = doc(db, `/artifacts/${appId}/public/data/sessions`, initialSession.id);
                const unsubscribe = onSnapshot(sessionRef, (doc) => {
                    if (doc.exists()) {
                        const data = { ...doc.data(), id: doc.id };
                        setSessionData(data);
                        const serverElements = JSON.parse(data.drawingData || '[]');
                        if (JSON.stringify(serverElements) !== JSON.stringify(elements)) {
                            setElements(serverElements);
                            const newHistory = [serverElements, ...history.slice(1)];
                            setHistory(newHistory);
                            setHistoryIndex(0);
                        }
                        if(data.theme && data.theme !== theme){ setTheme(data.theme); }
                    } else { onLeave(); }
                });
                 const cursorsRef = collection(db, `/artifacts/${appId}/public/data/sessions/${initialSession.id}/cursors`);
                const unsubscribeCursors = onSnapshot(cursorsRef, (snapshot) => {
                    const newCursors = {};
                    snapshot.forEach(doc => {
                        if (doc.id !== user.uid) { newCursors[doc.id] = doc.data(); }
                    });
                    setCursors(newCursors);
                });
                return () => { unsubscribe(); unsubscribeCursors(); };
            }, [initialSession.id, onLeave]);

            useEffect(() => { const canvas = canvasRef.current; const resize = () => { if (canvas) { canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight; } redrawCanvas(); }; window.addEventListener('resize', resize); resize(); return () => window.removeEventListener('resize', resize); }, [redrawCanvas]);
            useEffect(redrawCanvas, [redrawCanvas]);
            useEffect(() => { if (textInput.visible && textInputRef.current) { textInputRef.current.focus(); } }, [textInput.visible]);
            
            useEffect(() => {
                const canvas = canvasRef.current; if (!canvas) return;
                const handleKeyDown = (e) => { if (e.key === ' ') setIsSpacePressed(true); }; const handleKeyUp = (e) => { if (e.key === ' ') setIsSpacePressed(false); };
                const handleWheel = (e) => {
                    e.preventDefault(); const { clientX, clientY, deltaY } = e; const rect = canvas.getBoundingClientRect(); const mouseX = clientX - rect.left; const mouseY = clientY - rect.top;
                    const zoomFactor = 1.1; const newScale = deltaY < 0 ? viewTransform.scale * zoomFactor : viewTransform.scale / zoomFactor; const scale = Math.min(Math.max(newScale, 0.1), 20);
                    const worldX = (mouseX - viewTransform.offsetX) / viewTransform.scale; const worldY = (mouseY - viewTransform.offsetY) / viewTransform.scale;
                    const newOffsetX = mouseX - worldX * scale; const newOffsetY = mouseY - worldY * scale; setViewTransform({ scale, offsetX: newOffsetX, offsetY: newOffsetY });
                };
                window.addEventListener('keydown', handleKeyDown); window.addEventListener('keyup', handleKeyUp); canvas.addEventListener('wheel', handleWheel);
                return () => { window.removeEventListener('keydown', handleKeyDown); window.removeEventListener('keyup', handleKeyUp); canvas.removeEventListener('wheel', handleWheel); };
            }, [viewTransform]);

            const getTransformedCoords = (e) => {
                const canvas = canvasRef.current; if (!canvas) return { x: 0, y: 0 }; const rect = canvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX; const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return { x: (clientX - rect.left - viewTransform.offsetX) / viewTransform.scale, y: (clientY - rect.top - viewTransform.offsetY) / viewTransform.scale };
            };
            
            const createElement = (id, x, y, x2, y2) => {
                switch (tool) {
                    case 'pen': return { id, type: 'path', path: [{ x, y }], color, lineWidth };
                    case 'line': return { id, type: 'line', x, y, x2, y2, color, lineWidth };
                    case 'shape':
                        if (shape === 'rectangle') return { id, type: 'rectangle', x, y, width: x2 - x, height: y2 - y, color, lineWidth };
                        if (shape === 'circle') return { id, type: 'circle', x, y, radius: Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2)), color, lineWidth };
                        break;
                    case 'text': return { id, type: 'text', x, y, width: x2 - x, height: y2 - y, text: '', color, fontSize: FONT_SIZE };
                }
                return null;
            };
            
            const getElementAtPosition = (x, y, elements) => {
                for (let i = elements.length - 1; i >= 0; i--) {
                    const element = elements[i]; const bounds = getElementBounds(element); if (isPointInsideBounds({ x, y }, bounds)) { return element; }
                }
                return null;
            };

            const handleMouseDown = (e) => {
                if (userPermission !== 'draw' || textInput.visible) return;
                const { x, y } = getTransformedCoords(e); const screenCoords = {x: e.clientX, y: e.clientY};
                if (isSpacePressed) { setAction('panning'); setStartPoint(screenCoords); return; }
                if (tool === 'select') {
                    const element = getElementAtPosition(x, y, elements);
                    if (element) {
                        setSelectedElements([element.id]); setAction('moving'); setStartPoint({ x, y, originalElements: elements.filter(el => el.id === element.id) });
                    } else { setAction('selecting'); setStartPoint({x, y}); setSelectedElements([]); }
                } else if (tool === 'strokeEraser') {
                    const elementToDelete = getElementAtPosition(x, y, elements);
                    if (elementToDelete) { const updatedElements = elements.filter(el => el.id !== elementToDelete.id); setElements(updatedElements); updateHistory(updatedElements); }
                } else {
                    setAction('drawing'); const id = Date.now() + user.uid; const newElement = createElement(id, x, y, x, y);
                    if (newElement) { const newElements = [...elements, newElement]; setElements(newElements); setSelectedElements([newElement.id]); }
                }
            };

            const handleMouseMove = (e) => {
                if (userPermission !== 'draw' || action === 'none') return;
                const { x, y } = getTransformedCoords(e); const screenCoords = {x: e.clientX, y: e.clientY};
                
                const now = Date.now();
                if (now - lastCursorUpdate.current > 50) { // Throttle updates
                    const cursorRef = doc(db, `/artifacts/${appId}/public/data/sessions/${initialSession.id}/cursors`, user.uid);
                    setDoc(cursorRef, { x, y, name: sessionData.participants[user.uid]?.name || 'Anonymous' });
                    lastCursorUpdate.current = now;
                }

                if (action === 'panning') {
                    const dx = screenCoords.x - startPoint.x; const dy = screenCoords.y - startPoint.y;
                    setViewTransform(prev => ({ ...prev, offsetX: prev.offsetX + dx, offsetY: prev.offsetY + dy })); setStartPoint(screenCoords); return;
                }
                
                if (action === 'selecting') {
                    const rect = {
                        x: (Math.min(x, startPoint.x) * viewTransform.scale) + viewTransform.offsetX, y: (Math.min(y, startPoint.y) * viewTransform.scale) + viewTransform.offsetY,
                        width: Math.abs(x - startPoint.x) * viewTransform.scale, height: Math.abs(y - startPoint.y) * viewTransform.scale
                    };
                    setSelectionRect(rect); return;
                }

                if (action === 'drawing' && selectedElements.length === 1) {
                    const index = elements.findIndex(el => el.id === selectedElements[0]); if (index === -1) return;
                    const updatedElements = [...elements]; const currentElement = updatedElements[index]; const { type } = currentElement;
                    if (type === 'path') { currentElement.path.push({ x, y }); } else if (type === 'line') { currentElement.x2 = x; currentElement.y2 = y; } else if (type === 'rectangle' || type === 'text') { currentElement.width = x - currentElement.x; currentElement.height = y - currentElement.y; } else if (type === 'circle') { currentElement.radius = Math.sqrt(Math.pow(x - currentElement.x, 2) + Math.pow(y - currentElement.y, 2)); }
                    setElements(updatedElements);
                } else if (action === 'moving' && selectedElements.length > 0 && startPoint) {
                    const dx = x - startPoint.x; const dy = y - startPoint.y;
                    const updatedElements = elements.map(el => {
                        if (selectedElements.includes(el.id)) {
                            const originalElement = startPoint.originalElements.find(oel => oel.id === el.id); const movedElement = { ...originalElement, id: el.id };
                            if (movedElement.type === 'path') { movedElement.path = originalElement.path.map(p => ({ x: p.x + dx, y: p.y + dy })); } else if (movedElement.type === 'line') { movedElement.x = originalElement.x + dx; movedElement.y = originalElement.y + dy; movedElement.x2 = originalElement.x2 + dx; movedElement.y2 = originalElement.y2 + dy; } else { movedElement.x = originalElement.x + dx; movedElement.y = originalElement.y + dy; }
                            return movedElement;
                        }
                        return el;
                    });
                    setElements(updatedElements);
                }
            };

            const handleMouseUp = () => {
                if (action === 'selecting' && selectionRect) {
                    const worldRect = { x: (selectionRect.x - viewTransform.offsetX) / viewTransform.scale, y: (selectionRect.y - viewTransform.offsetY) / viewTransform.scale, width: selectionRect.width / viewTransform.scale, height: selectionRect.height / viewTransform.scale, };
                    const selectedIds = elements.filter(element => { const bounds = getElementBounds(element); return bounds && doBoundsIntersect(bounds, worldRect); }).map(el => el.id);
                    setSelectedElements(selectedIds); setSelectionRect(null);
                } else if (action === 'drawing' && tool === 'text') {
                    const textElement = elements.find(el => el.id === selectedElements[0]); if (!textElement) return;
                    setAction('writing'); const bounds = getElementBounds(textElement);
                    setTextInput({ visible: true, x: bounds.x, y: bounds.y, width: bounds.width, height: bounds.height, value: '' });
                } else { if (action === 'drawing' || action === 'moving') { updateHistory(elements); } }
                setAction('none'); setStartPoint(null);
            };

            const handleTextBlur = () => {
                if (selectedElements.length !== 1) return; const textElementId = selectedElements[0];
                const updatedElements = elements.map(el => { if (el.id === textElementId) { return { ...el, text: textInput.value }; } return el; });
                if (!textInput.value.trim()) { const finalElements = updatedElements.filter(el => el.id !== textElementId); setElements(finalElements); updateHistory(finalElements); } else { setElements(updatedElements); updateHistory(updatedElements); }
                setTextInput({ visible: false, x: 0, y: 0, width: 0, height: 0, value: '' }); setAction('none'); setSelectedElements([]);
            };
            
            const handleClearCanvas = async () => { if (!isHost) return; setElements([]); updateHistory([]); };

            return (
                <div className={`screen ${isSpacePressed || action === 'panning' ? 'cursor-grabbing' : ''}`}>
                    <Header sessionData={sessionData} onLeave={onLeave} user={user} theme={theme} setTheme={setTheme} />
                    <div className="flex flex-1" style={{overflow: 'hidden'}}>
                        <div className="flex-1 flex flex-col p-4 relative">
                            <canvas ref={canvasRef}
                                onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp}
                                className={`main-canvas ${userPermission === 'draw' ? 'cursor-crosshair' : 'cursor-not-allowed'}`}
                            />
                            <CursorOverlay cursors={cursors} viewTransform={viewTransform} />
                            {textInput.visible && (
                                <textarea
                                    ref={textInputRef}
                                    value={textInput.value}
                                    onChange={(e) => setTextInput(prev => ({ ...prev, value: e.target.value }))}
                                    onBlur={handleTextBlur}
                                    style={{
                                        position: 'absolute',
                                        left: `${(textInput.x * viewTransform.scale) + viewTransform.offsetX + 16}px`,
                                        top: `${(textInput.y * viewTransform.scale) + viewTransform.offsetY + 16}px`,
                                        width: `${Math.abs(textInput.width) * viewTransform.scale}px`,
                                        height: `${Math.abs(textInput.height) * viewTransform.scale}px`,
                                        border: `1px solid var(--accent-primary)`,
                                        background: 'var(--bg-secondary)', color: 'var(--text-primary)',
                                        outline: 'none', zIndex: 20, fontSize: FONT_SIZE * viewTransform.scale, 
                                        fontFamily: 'inherit',
                                        resize: 'none', lineHeight: LINE_HEIGHT,
                                        padding: `${4 * viewTransform.scale}px`
                                    }}
                                />
                            )}
                            {userPermission === 'pending' && <PendingApprovalOverlay />}
                            {userPermission === 'watch' && <WatchOnlyOverlay />}
                            <div className="zoom-indicator">
                                {Math.round(viewTransform.scale * 100)}%
                            </div>
                        </div>
                        <Sidebar sessionData={sessionData} user={user} />
                    </div>
                    {userPermission === 'draw' && <Toolbar tool={tool} setTool={setTool} shape={shape} setShape={setShape} color={color} setColor={setColor} lineWidth={lineWidth} setLineWidth={setLineWidth} onClear={handleClearCanvas} isHost={isHost} quickColors={quickColors} setQuickColors={setQuickColors} onUndo={handleUndo} onRedo={handleRedo} canUndo={historyIndex > 0} canRedo={historyIndex < history.length - 1} />}
                </div>
            );
        }

        // --- Other Components ---
        function Toolbar({ tool, setTool, shape, setShape, color, setColor, lineWidth, setLineWidth, onClear, isHost, quickColors, setQuickColors, onUndo, onRedo, canUndo, canRedo }) {
            const colorPickerRef = useRef(null);
            const [editingColorIndex, setEditingColorIndex] = useState(null);

            const handleQuickColorChange = (e) => {
                const newColor = e.target.value;
                const newQuickColors = [...quickColors];
                newQuickColors[editingColorIndex] = newColor;
                setQuickColors(newQuickColors);
                setColor(newColor);
            };

            const tools = [
                { id: 'select', icon: 'MousePointer', label: 'Select & Move (Drag on canvas for multi-select)' },
                { id: 'pen', icon: 'Edit', label: 'Pen' },
                { id: 'line', icon: 'Minus', label: 'Line' },
                { id: 'shape', icon: 'Square', label: 'Shape' },
                { id: 'text', icon: 'Type', label: 'Text' },
                { id: 'strokeEraser', icon: 'SquareSlash', label: 'Eraser' }
            ];

            return (
                <div className="toolbar">
                    <div className="tool-group">
                        <button onClick={onUndo} disabled={!canUndo} title="Undo" className="toolbar-btn"><Icon name="Undo" /></button>
                        <button onClick={onRedo} disabled={!canRedo} title="Redo" className="toolbar-btn"><Icon name="Redo" /></button>
                    </div>
                    <div className="divider" />
                    <div className="tool-group">
                        {tools.map(t => <button key={t.id} onClick={() => setTool(t.id)} title={t.label} className={`toolbar-btn ${tool === t.id ? 'active' : ''}`}><Icon name={t.icon} /></button>)}
                    </div>
                    {tool === 'shape' && (
                        <div className="tool-group">
                            <button onClick={() => setShape('rectangle')} className={`toolbar-btn ${shape === 'rectangle' ? 'active' : ''}`}><Icon name="Square" /></button>
                            <button onClick={() => setShape('circle')} className={`toolbar-btn ${shape === 'circle' ? 'active' : ''}`}><Icon name="Circle" /></button>
                        </div>
                    )}
                    <div className="divider" />
                    <div className="color-palette">
                        {quickColors.map((c, i) => (
                            <div key={i} className="color-picker-wrapper">
                                <button onClick={() => setColor(c)} className={`color-btn ${color === c ? 'active' : ''}`} style={{ backgroundColor: c }} />
                                <button onClick={() => { setEditingColorIndex(i); colorPickerRef.current.click(); }} className="color-picker-btn"><Icon name="Pipette" size={12} /></button>
                            </div>
                        ))}
                        <input type="color" ref={colorPickerRef} onChange={handleQuickColorChange} className="color-input" />
                    </div>
                    <div className="divider" />
                    <div className="tool-group">
                        <button onClick={() => setLineWidth(Math.max(1, lineWidth - 2))} className="toolbar-btn"><Icon name="Minus" /></button>
                        <span style={{width: '2rem', textAlign: 'center'}}>{lineWidth}</span>
                        <button onClick={() => setLineWidth(Math.min(50, lineWidth + 2))} className="toolbar-btn"><Icon name="Plus" /></button>
                    </div>
                    {isHost && (<>
                        <div className="divider" />
                        <button onClick={onClear} className="btn btn-purge"><Icon name="Trash2" size={16} /> <span style={{marginLeft: '0.5rem'}}>Purge</span></button>
                    </>)}
                </div>
            );
        }

        function ThemeSelector({theme, setTheme, session}) {
            const handleThemeChange = (newTheme) => {
                setTheme(newTheme);
                if(session && session.id) {
                    const sessionRef = doc(db, `/artifacts/${appId}/public/data/sessions`, session.id);
                    updateDoc(sessionRef, { theme: newTheme });
                }
            };

            // return (
            //     <div className="theme-selector">
            //          <button className="toolbar-btn"><Icon name="Palette" /></button>
            //         <div className="theme-dropdown">
            //             {Object.entries(themes).map(([name, values]) => (
            //                 <button key={name} onClick={() => handleThemeChange(name)} className={`theme-btn ${theme === name ? 'active' : ''}`} title={name}
            //                    style={{background: values['--bg-primary'], border: `2px solid ${values['--accent-primary']}`}}
            //                 />
            //             ))}
            //         </div>
            //     </div>
            // );
        }

        function CursorOverlay({ cursors, viewTransform }) {
            return (
                <div className="cursor-overlay">
                    {Object.entries(cursors).map(([uid, cursor]) => (
                        <div key={uid} className="user-cursor" style={{
                            transform: `translate(${(cursor.x * viewTransform.scale) + viewTransform.offsetX}px, ${(cursor.y * viewTransform.scale) + viewTransform.offsetY}px)`,
                            transition: 'transform 0.1s linear'
                        }}>
                            <Icon name="MousePointer" size={20} color={cursor.color || 'var(--accent-secondary)'} />
                            <span className="user-cursor-label" style={{ backgroundColor: cursor.color || 'var(--accent-secondary)', color: 'var(--bg-primary)' }}>
                                {cursor.name}
                            </span>
                        </div>
                    ))}
                </div>
            );
        }

        function Header({ sessionData, onLeave, user, theme, setTheme }) {
            const [copyText, setCopyText] = useState('Copy');
            const handleCopy = () => {
                navigator.clipboard.writeText(sessionData.shortCode);
                setCopyText('Copied!');
                setTimeout(() => setCopyText('Copy'), 2000);
            };

            return (
                <header className="header flex items-center justify-between">
                    <div className="flex items-center">
                        <h1>GRIDSPACE</h1>
                        <div className="coords-group flex items-center gap-2">
                            <span className="coords-label">Coords:</span>
                            <span className="coords-code">{sessionData.shortCode}</span>
                            <button onClick={handleCopy} className="btn-icon" style={{padding: '0.25rem 0.5rem', fontSize: '0.75rem', border: '1px solid var(--border-primary)', color: 'var(--text-secondary)'}}>{copyText}</button>
                        </div>
                    </div>
                    <div className="flex items-center gap-4">
                        <ThemeSelector theme={theme} setTheme={setTheme} session={sessionData} />
                        <span className="user-info">User: {sessionData.participants[user.uid]?.name || 'Guest'}</span>
                        <button onClick={onLeave} className="btn btn-leave"><Icon name="LogOut" size={16} /><span style={{marginLeft: '0.5rem'}}>Disconnect</span></button>
                    </div>
                </header>
            );
        }
        function Sidebar({ sessionData, user }) {
            const isHost = sessionData.hostId === user.uid;
            const sessionRef = doc(db, `/artifacts/${appId}/public/data/sessions`, sessionData.id);
            const handlePermissionChange = async (targetUserId, permission) => {
                if (!isHost) return;
                await updateDoc(sessionRef, { [`participants.${targetUserId}.permission`]: permission });
            };
            const handleRequest = async (requestingUserId, approve) => {
                if (!isHost) return;
                const requestorData = sessionData.pendingRequests[requestingUserId];
                const currentRequests = { ...sessionData.pendingRequests };
                delete currentRequests[requestingUserId];
                const updates = { pendingRequests: currentRequests };
                if (approve) {
                    updates[`participants.${requestingUserId}`] = { name: requestorData.name, permission: 'watch' };
                }
                await updateDoc(sessionRef, updates);
            };
            return (
                <aside className="sidebar">
                    {isHost && Object.keys(sessionData.pendingRequests || {}).length > 0 && (
                        <div style={{marginBottom: '1.5rem'}}>
                            <h3>Incoming Syncs</h3>
                            <div style={{display: 'flex', flexDirection: 'column', gap: '0.5rem'}}>
                                {Object.entries(sessionData.pendingRequests).map(([uid, data]) => (
                                    <div key={uid} className="pending-request flex items-center justify-between">
                                        <span>{data.name}</span>
                                        <div className="flex gap-2">
                                            <button onClick={() => handleRequest(uid, true)} className="btn-icon"><Icon name="Check" /></button>
                                            <button onClick={() => handleRequest(uid, false)} className="btn-icon"><Icon name="X" /></button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}
                    <div>
                        <h3>Connected Users</h3>
                         <p className="invite-text">Share the Coords with your friends to have them join the board!</p>
                        <div style={{display: 'flex', flexDirection: 'column', gap: '0.75rem'}}>
                            {Object.entries(sessionData.participants).map(([uid, data]) => {
                                if (!data) return null; // FIX: Prevents crash if a participant leaves
                                return (
                                <div key={uid} className="participant-card">
                                    <div className="flex items-center justify-between">
                                        <span style={{fontWeight: 600, color: uid === user.uid ? 'var(--accent-primary)' : 'var(--text-primary)'}}>{data.name} {uid === sessionData.hostId && '(Host)'} {uid === user.uid && '(You)'}</span>
                                        {data.permission === 'draw' ? <Icon name="Edit" size={16} /> : <Icon name="Eye" size={16} />}
                                    </div>
                                    {isHost && uid !== user.uid && (
                                        <div className="flex gap-2" style={{marginTop: '0.75rem'}}>
                                            <button onClick={() => handlePermissionChange(uid, 'draw')} disabled={data.permission === 'draw'} className="btn-permission btn-allow-draw">Allow Draw</button>
                                            <button onClick={() => handlePermissionChange(uid, 'watch')} disabled={data.permission === 'watch'} className="btn-permission btn-watch-only">Watch Only</button>
                                        </div>
                                    )}
                                </div>
                            )})}
                        </div>
                    </div>
                </aside>
            );
        }
        function PendingApprovalOverlay() {
            return (
                <div className="overlay">
                    <h2>Awaiting Sync Approval</h2>
                    <p>Host has been notified of your connection request.</p>
                </div>
            );
        }
        function WatchOnlyOverlay() {
            return (
                <div className="watch-only-badge">
                    <Icon name="Eye" size={16} /> Observation Mode
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
